<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Navia AI Beta</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            /* Branding & Dark Mode */
            --primary-color: #0072FF;
            --secondary-color: #00C6FF;
            --primary-gradient: linear-gradient(135deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            --bg-color: #050509;
            --chat-bg: #0f1016;
            --header-bg: rgba(5, 5, 9, 0.9);
            --user-msg-bg: var(--primary-color);
            --ai-msg-bg: #1a1c29;
            --text-color: #e0e6ed;
            --border-color: rgba(255, 255, 255, 0.08);
            --error-color: #ef4444;
            --button-color: #94a3b8;
            --action-btn-bg: rgba(255, 255, 255, 0.1);
            --action-btn-hover: rgba(0, 114, 255, 0.2);
            --mode-inactive-bg: rgba(255, 255, 255, 0.05);
            --mode-active-bg: var(--primary-color);
            --mode-active-text: white;
            --abort-color: #ef4444;

            /* Memory Modal Colors */
            --modal-bg: #1a1c29;
            --modal-border: #00C6FF;
            --memory-item-bg: #0f1016;
            --delete-btn-bg: #ef4444;
            --delete-btn-hover: #dc2626;
        }

        /* Light Mode */
        body.light-mode {
            --bg-color: #f7f7f7;
            --chat-bg: #ffffff;
            --header-bg: rgba(255, 255, 255, 0.95);
            --ai-msg-bg: #f0f0f5;
            --text-color: #1f2937;
            --border-color: rgba(0, 0, 0, 0.1);
            --button-color: #4b5563;
            --action-btn-bg: rgba(0, 0, 0, 0.05);
            --action-btn-hover: rgba(0, 114, 255, 0.1);
            --mode-inactive-bg: rgba(0, 0, 0, 0.05);
            --mode-active-bg: var(--primary-color);
            --mode-active-text: white;

            /* Memory Modal Colors Light */
            --modal-bg: #ffffff;
            --modal-border: #0072FF;
            --memory-item-bg: #f0f0f5;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Inter', 'Segoe UI', Roboto, sans-serif; }
        
        /* Button- und Textarea-Reset */
        button, textarea {
            appearance: none;
            -webkit-appearance: none;
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            outline: none;
        }
        
        body { background-color: var(--bg-color); color: var(--text-color); height: 100dvh; display: flex; flex-direction: column; overflow: hidden; transition: background-color 0.3s; }

        /* Hintergrund-Effekte */
        .bg-glow { position: fixed; width: 300px; height: 300px; background: var(--primary-gradient); filter: blur(150px); border-radius: 50%; opacity: 0.15; z-index: -1; pointer-events: none; }
        .glow-1 { top: -100px; left: -100px; }
        .glow-2 { bottom: -100px; right: -100px; }

        /* --- Header / Modus Selector --- */
        header { 
            padding: 15px 20px; 
            background: var(--header-bg); 
            backdrop-filter: blur(12px); 
            border-bottom: 1px solid var(--border-color); 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            z-index: 100; 
            color: var(--text-color);
        }
        
        .header-left { display: flex; align-items: center; gap: 20px; }
        .logo { 
            font-size: 1.4rem; font-weight: 800; background: var(--primary-gradient); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
            display: flex; align-items: center; gap: 12px; white-space: nowrap;
        }
        .badge { 
            font-size: 0.65rem; background: rgba(0, 198, 255, 0.15); color: #00C6FF; 
            padding: 3px 8px; border-radius: 20px; border: 1px solid rgba(0, 198, 255, 0.2); 
            font-weight: 700;
        }
        
        /* Modus Selector */
        .mode-selector {
            display: flex;
            background: var(--mode-inactive-bg);
            border-radius: 20px;
            padding: 4px;
        }
        .mode-selector button {
            background: none;
            border: none;
            color: var(--button-color);
            padding: 6px 10px; /* Leicht angepasst f√ºr 3 Buttons */
            border-radius: 16px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }
        .mode-selector button.active-mode-btn {
            background: var(--mode-active-bg);
            color: var(--mode-active-text);
            box-shadow: 0 2px 5px rgba(0, 114, 255, 0.3);
        }
        
        /* Container f√ºr die gesamte rechte Seite */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 15px; 
        }
        
        /* Linke Gruppe der rechten Seite: Memory, Token, Model */
        .status-group {
            display: flex;
            align-items: center;
            gap: 15px; 
            height: 20px; 
        }
        
        /* Rechte Gruppe der rechten Seite: Buttons */
        .action-buttons-group {
            display: flex;
            align-items: center;
            gap: 15px;
            padding-left: 15px; 
            border-left: 1px solid var(--border-color); 
        }

        .model-info { 
            font-size: 0.75rem; 
            color: var(--button-color); 
            cursor: pointer; 
            display: flex;
            align-items: center;
            white-space: nowrap; 
            transition: color 0.2s;
        }
        .model-info:hover {
            color: var(--primary-color);
        }

        #memory-status i {
            margin-right: 5px;
            color: #facc15; 
            transition: transform 0.3s;
        }
        #memory-status.active i {
            color: #22c55e; 
            transform: scale(1.1);
        }
        
        /* --- Buttons im Header --- */
        .action-btn {
            background: none;
            border: none;
            color: var(--button-color);
            cursor: pointer;
            font-size: 1rem;
            transition: color 0.2s, transform 0.1s;
        }
        .action-btn:hover {
            color: var(--primary-color);
        }
        
        #delete-all-data-btn {
            font-size: 1.1rem;
        }
        
        /* Media Query f√ºr kleine Bildschirme */
        @media (max-width: 850px) {
            .mode-selector { display: none; }
            .header-left { width: 100%; justify-content: space-between; }
            .status-group { 
                display: none; 
            }
            .action-buttons-group {
                gap: 10px;
                padding-left: 0;
                border-left: none;
            }
        }
        
        /* --- Chat Area --- */
        #chat-container { 
            flex: 1; 
            overflow-y: auto; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            gap: 24px; 
            scroll-behavior: smooth; 
            background-color: var(--chat-bg);
            display: flex; 
        }
        
        .message-wrapper { position: relative; display: flex; flex-direction: column; align-items: flex-start; }
        .message-wrapper.user-wrapper { align-items: flex-end; }
        .message { max-width: 88%; padding: 14px 20px; border-radius: 20px; line-height: 1.6; font-size: 0.98rem; word-wrap: break-word; }
        .message.user { background: var(--user-msg-bg); color: white; border-bottom-right-radius: 4px; }
        .message.ai { 
            background: var(--ai-msg-bg); 
            border: 1px solid var(--border-color); 
            border-bottom-left-radius: 4px; 
            color: var(--text-color);
        }

        /* Code Block Styling (highlight.js) */
        .message.ai pre {
            background: #1e1e1e !important;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .message.ai code {
            background: none !important;
            color: inherit !important;
            padding: 0 !important;
            border-radius: 0 !important;
            white-space: pre; 
        }
        /* Inline Code */
        .message.ai p code {
            background: rgba(0, 114, 255, 0.1);
            color: var(--primary-color);
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        /* --- Message Actions (Buttons) --- */
        .message-actions { margin-top: 5px; display: flex; gap: 8px; padding-left: 10px; }
        
        .copy-btn {
            background: var(--action-btn-bg); border: 1px solid transparent; 
            color: var(--text-color); padding: 5px 10px; border-radius: 8px;
            cursor: pointer; font-size: 0.8rem; line-height: 1.5;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .copy-btn:hover { 
            background: var(--action-btn-hover); color: var(--primary-color); 
            border-color: var(--primary-color);
        }
        .hide-notice-btn, .abort-notice-btn {
            background: var(--action-btn-bg); border: 1px solid transparent;
            color: var(--button-color); 
        }
        .hide-notice-btn:hover, .abort-notice-btn:hover {
            background: var(--error-color); border-color: var(--error-color);
            color: white;
        }
        .summarize-btn {
            background: rgba(34, 197, 94, 0.15); 
            color: #22c55e;
            border-color: rgba(34, 197, 94, 0.3);
        }
        .summarize-btn:hover {
            background: rgba(34, 197, 94, 0.3);
            color: #15803d;
            border-color: #22c55e;
        }
        /* Vorlese-Button */
        .speak-btn {
            background: rgba(255, 165, 0, 0.15); 
            color: #ffa500;
            border-color: rgba(255, 165, 0, 0.3);
        }
        .speak-btn:hover {
            background: rgba(255, 165, 0, 0.3);
            color: #cc8400;
            border-color: #ffa500;
        }
        
        /* --- Input Area --- */
        .input-area { 
            padding: 15px 20px; background: var(--header-bg); 
            border-top: 1px solid var(--border-color); display: flex; 
            gap: 12px; align-items: flex-end; 
        }
        .input-wrapper { 
            flex: 1; background: var(--ai-msg-bg); border-radius: 24px; 
            border: 1px solid var(--border-color); padding: 12px 20px; 
            display: flex; align-items: center; 
        }
        
        #user-input {
            flex: 1;
            background: transparent;
            border: none; 
            color: var(--text-color);
            resize: none;
            overflow-y: hidden;
            font-size: 1rem;
            line-height: 1.5em;
            padding: 0;
            margin: 0;
            outline: none; 
            height: 1.5em; 
            min-height: 1.5em;
        }
        
        /* Deaktivierter Zustand f√ºr Textarea */
        #user-input:disabled {
            cursor: text; /* Erlaubt das Markieren/Kopieren */
            opacity: 0.7;
        }


        button#voice-btn, button#improve-prompt-btn, button#undo-improve-btn {
            background: none;
            border: none;
            color: var(--button-color);
            cursor: pointer;
            padding: 0;
            transition: color 0.2s, opacity 0.2s;
            line-height: 1;
            margin-left: 10px; /* Abstand zur Textarea */
        }
        
        button#voice-btn {
            font-size: 1.2rem; 
            margin-left: 0;
            margin-right: 10px;
        }

        button#improve-prompt-btn, button#undo-improve-btn {
            font-size: 0.9rem;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 5px;
            color: #8b5cf6; /* Lila f√ºr "Verbessern" */
        }
        
        button#undo-improve-btn {
            color: #ef4444; /* Rot f√ºr "R√ºckg√§ngig" */
            display: none; /* Initial versteckt */
        }

        button#voice-btn:hover { color: var(--primary-color); }
        button#voice-btn.listening { color: var(--abort-color); }
        button#improve-prompt-btn:hover { color: var(--primary-color); }
        button#undo-improve-btn:hover { color: var(--abort-color); }
        
        /* Sende-Button */
        button#send-btn { 
            background: var(--primary-gradient); 
            border: none; 
            width: 50px; 
            height: 50px; 
            border-radius: 50%; 
            color: white; 
            cursor: pointer; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            box-shadow: 0 4px 15px rgba(0, 114, 255, 0.3); 
            flex-shrink: 0; 
            transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
        }
        
        button#send-btn.abort-mode { 
            background: var(--abort-color); 
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3); 
        }

        button#send-btn:disabled { 
            opacity: 0.5; 
            filter: grayscale(1); 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none; /* Deaktivierte Buttons haben keinen Schatten */
        }
        
        /* Welcome Screen und Suggestions */
        .welcome-screen { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center; opacity: 1; }
        .welcome-screen.hidden { display: none; }
        .welcome-screen h1 { font-size: 3rem; margin-bottom: 15px; background: linear-gradient(to right, var(--text-color), var(--button-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .welcome-screen p { color: var(--button-color); font-size: 1.1rem; max-width: 600px; line-height: 1.6; margin-bottom: 40px; }
        #suggestion-box { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; max-width: 800px; margin-top: 20px; }
        .suggestion-chip { background: var(--ai-msg-bg); border: 1px solid var(--border-color); color: var(--text-color); padding: 10px 15px; border-radius: 25px; cursor: pointer; font-size: 0.9rem; transition: background 0.2s, transform 0.1s, border-color 0.2s; }
        .suggestion-chip:hover { background: var(--action-btn-hover); border-color: var(--primary-color); color: var(--primary-color); }
        
        /* Typing Indicator */
        .typing-indicator { display: none; align-self: flex-start; background: var(--ai-msg-bg); padding: 15px 20px; border-radius: 20px; border-bottom-left-radius: 4px; border: 1px solid var(--border-color); width: fit-content; margin-bottom: 24px; }
        .dot { height: 7px; width: 7px; margin: 0 3px; background-color: #00C6FF; border-radius: 50%; display: inline-block; animation: bounce 1.4s infinite ease-in-out both; }
        .dot:nth-child(1) { animation-delay: -0.32s; } .dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

        /* ========================================================================= */
        /* MEMORY MODAL STYLES */
        /* ========================================================================= */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-overlay.open {
            opacity: 1; pointer-events: all;
        }

        .memory-modal {
            background: var(--modal-bg); color: var(--text-color);
            width: 90%; max-width: 600px; padding: 25px; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 2px solid var(--modal-border);
            transform: scale(0.9); transition: transform 0.3s ease;
        }
        .modal-overlay.open .memory-modal {
            transform: scale(1);
        }

        .memory-modal h2 {
            margin-bottom: 15px; font-size: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 10px;
        }

        /* Input area for new memories */
        .memory-input-group {
            display: flex; gap: 10px; margin-bottom: 20px;
        }
        #new-memory-input {
            flex-grow: 1; padding: 10px; border-radius: 8px; 
            border: 1px solid var(--border-color); background: var(--memory-item-bg);
            color: var(--text-color); font-size: 1rem;
        }
        #add-memory-btn {
            background: var(--primary-color); color: white; padding: 10px 15px;
            border-radius: 8px; cursor: pointer; transition: background 0.2s;
        }
        #add-memory-btn:hover { background: var(--secondary-color); }

        /* List of memories */
        #memory-list {
            max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;
            padding-right: 5px;
        }
        .memory-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--memory-item-bg); border-radius: 8px;
            font-size: 0.95rem; border: 1px solid var(--border-color);
        }
        .memory-text {
            flex-grow: 1; margin-right: 15px; word-break: break-word;
        }
        .delete-memory-btn {
            background: var(--delete-btn-bg); color: white; border-radius: 5px;
            padding: 5px 8px; cursor: pointer; font-size: 0.8rem; line-height: 1;
            transition: background 0.2s;
        }
        .delete-memory-btn:hover {
            background: var(--delete-btn-hover);
        }

        /* Footer buttons */
        .memory-modal-footer {
            display: flex; justify-content: space-between; margin-top: 20px;
            border-top: 1px solid var(--border-color); padding-top: 15px;
        }
        #delete-all-memories-btn {
            background: var(--delete-btn-bg); color: white; padding: 10px 15px;
            border-radius: 8px; cursor: pointer; transition: background 0.2s;
        }
        #delete-all-memories-btn:hover { background: var(--delete-btn-hover); }

        #close-memory-modal-btn {
            background: var(--action-btn-bg); color: var(--text-color); padding: 10px 15px;
            border-radius: 8px; cursor: pointer; transition: background 0.2s;
        }
        #close-memory-modal-btn:hover { background: var(--action-btn-hover); color: var(--primary-color); }
        
        .empty-memory-list {
            color: var(--button-color);
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="bg-glow glow-1"></div>
    <div class="bg-glow glow-2"></div>

    <header>
        <div class="header-left">
            <div class="logo"><i class="fa-solid fa-atom"></i> Navia AI <span class="badge">Beta</span></div>
            
            <div class="mode-selector">
                <button id="mode-auto-btn" class="active-mode-btn" title="Automatische Erkennung: Trivial schnell, Komplex detailliert."><i class="fa-solid fa-microchip"></i> Automatisch</button>
                <button id="mode-fast-btn" title="Schnelle Antwort (1 API-Aufruf)"><i class="fa-solid fa-bolt"></i> Schnell</button>
                <button id="mode-smart-btn" title="Gepr√ºfte Antwort (2 API-Aufrufe)"><i class="fa-solid fa-graduation-cap"></i> Schlau</button>
            </div>
        </div>
        
        <div class="header-actions">
            <div class="status-group">
                <span class="model-info" id="memory-status" title="Klicken Sie, um die gespeicherten Details zu verwalten."><i class="fa-solid fa-brain"></i> Memory: Off</span>
                <span class="model-info" id="token-display" title="Der Token-Z√§hler zeigt die aktuelle L√§nge des Gespr√§chs an (ca. 4 Zeichen pro Token).">Tokens: 0</span>
                <span class="model-info" id="model-display">Model: Llama 3.2</span>
            </div>

            <div class="action-buttons-group">
                <button class="action-btn" id="delete-all-data-btn" title="Chat-Historie UND gespeicherte Erinnerungen (Memory) l√∂schen"><i class="fa-solid fa-trash-can"></i></button>
                <button class="action-btn" id="theme-toggle-btn" title="Design wechseln"><i class="fa-solid fa-sun"></i></button>
                <button class="action-btn" id="clear-chat-btn" title="Neuen Chat starten (l√∂scht nur Historie)"><i class="fa-solid fa-comment-dots"></i></button>
            </div>
        </div>
    </header>

    <div id="chat-container">
        <div class="welcome-screen" id="welcome-screen">
            <h1>Navia AI</h1>
            <p>
                Hallo, dies ist deine **private KI**. 
                Frag mich alles! Deine Gespr√§che werden **nicht** an Dritte gesendet. 
                Die Historie wird **lokal** gespeichert, bis Sie sie l√∂schen.
            </p>
            
            <div id="suggestion-box"></div>
        </div>
    </div>

    <div class="typing-indicator" id="loading-indicator">
        <div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>

    <div class="input-area">
        <div class="input-wrapper">
             <button id="voice-btn" title="Spracheingabe starten"><i class="fa-solid fa-microphone"></i></button>
            <textarea id="user-input" placeholder="Nachricht an Navia..." rows="1"></textarea>
            
            <button id="improve-prompt-btn" title="Lass die KI deinen Prompt verbessern, um bessere Antworten zu erhalten"><i class="fa-solid fa-wand-magic-sparkles"></i> Prompt verbessern</button>
            <button id="undo-improve-btn" title="Verbesserung r√ºckg√§ngig machen"><i class="fa-solid fa-rotate-left"></i> R√ºckg√§ngig</button>
        </div>
        <button id="send-btn" title="Senden"><i class="fa-solid fa-paper-plane"></i></button>
    </div>
    
    <div class="modal-overlay" id="memory-modal-overlay">
        <div class="memory-modal">
            <h2><i class="fa-solid fa-brain"></i> Navia Memory Manager</h2>
            
            <p style="margin-bottom: 15px; font-size: 0.9rem; color: var(--button-color);">
                F√ºgen Sie Details hinzu, an die sich Navia in allen zuk√ºnftigen Chats erinnern soll.
            </p>
            
            <div class="memory-input-group">
                <input type="text" id="new-memory-input" placeholder="Neues Detail merken (z.B. Ich bin Webentwickler)">
                <button id="add-memory-btn"><i class="fa-solid fa-plus"></i> Hinzuf√ºgen</button>
            </div>
            
            <h3>Gespeicherte Details (<span id="memory-count">0</span>):</h3>
            <div id="memory-list">
                </div>
            
            <div class="memory-modal-footer">
                <button id="delete-all-memories-btn" title="L√∂scht alle gespeicherten Memory-Eintr√§ge"><i class="fa-solid fa-trash-can"></i> Alle l√∂schen</button>
                <button id="close-memory-modal-btn"><i class="fa-solid fa-xmark"></i> Schlie√üen</button>
            </div>
        </div>
    </div>

    <script>
        // Tokenizer
        function countTokens(text) {
            if (!text) return 0;
            // Ungef√§hre Z√§hlung: 4 Zeichen pro Token
            return Math.ceil(text.length / 4); 
        }
        
        // MARKED UND HIGHLIGHT.JS SETUP (Syntax Highlighting)
        marked.setOptions({
            gfm: true,
            breaks: true,
            sanitize: true, 
            highlight: function(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                return hljs.highlight(code, { language }).value;
            }
        });

        // =========================================================================
        // KONSTANTEN & FEHLER CODES
        // =========================================================================
        // üö® WICHTIG: Ersetzen Sie den Platzhalter-Schl√ºssel unten durch Ihren eigenen, g√ºltigen API-Schl√ºssel.
        const API_KEY = "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"; 
        const API_URL = "https://router.huggingface.co/v1/chat/completions";
        const MODEL = "meta-llama/Llama-3.1-70B-Instruct";
        const IMPROVE_MODEL = "meta-llama/Llama-3.1-70B-Instruct"; 
        
        // Benutzerdefinierte Fehlercodes (3-stellig)
        const ERROR_CODES = {
            NETWORK_FETCH_ERROR: '501', 
            API_KEY_ERROR: '401',      
            API_HTTP_ERROR: '502',     
            PROMPT_IMPROVE_ERROR: '601',
            GENERAL_FALLBACK: '000'
        };
        
        // Sicherheitseinschr√§nkungen jetzt deaktiviert
        const RESTRICTED_KEYWORDS = [
        ];
        const RESTRICTION_RESPONSE = "Fehler (Code:000)";


        // =========================================================================
        // VORGESCHLAGENE FRAGEN 
        // =========================================================================
        const SUGGESTIONS = {
            "Wissen & Erkl√§rung": [
                { text: "Erkl√§re die Relativit√§tstheorie in einfachen Worten.", category: "Wissen" },
                { text: "Was sind Quantencomputer und wie funktionieren sie?", category: "Wissen" },
                { text: "Fasse die Geschichte des Internets kurz zusammen.", category: "Wissen" },
                { text: "Wie entsteht ein Schwarzes Loch?", category: "Wissen" }
            ],
            "Kreativit√§t & Schreiben": [
                { text: "Schreibe ein kurzes, lustiges Gedicht √ºber eine sprechende Katze.", category: "Kreativit√§t" },
                { text: "Erfinde den Anfang einer Science-Fiction-Geschichte.", category: "Kreativit√§t" },
                { text: "Formuliere einen kurzen Werbeslogan f√ºr einen neuen Bio-Kaffee.", category: "Kreativit√§t" },
                { text: "√úbersetze 'Das ist eine tolle Funktion!' ins Englische und Spanische.", category: "Kreativit√§t" }
            ],
            "Alltag & Produktivit√§t": [
                { text: "Erstelle eine Einkaufsliste f√ºr ein Abendessen mit drei G√§ngen.", category: "Produktivit√§t" },
                { text: "Nenne drei schnelle Fitness√ºbungen f√ºr das B√ºro.", category: "Produktivit√§t" },
                { text: "Wie schreibe ich einen perfekten Lebenslauf?", category: "Produktivit√§t" },
                { text: "Was sind die besten Apps f√ºr Zeiterfassung?", category: "Produktivit√§t" }
            ]
        };

        function populateSuggestions() {
            const suggestionBox = document.getElementById('suggestion-box');
            suggestionBox.innerHTML = '';
            
            const categories = Object.keys(SUGGESTIONS);
            const selectedSuggestions = [];
            
            categories.forEach(category => {
                const available = SUGGESTIONS[category];
                const randomIndex = Math.floor(Math.random() * available.length);
                selectedSuggestions.push(available[randomIndex]);
            });

            selectedSuggestions.forEach(item => {
                const chip = document.createElement('div');
                chip.classList.add('suggestion-chip');
                chip.setAttribute('data-prompt', item.text);
                chip.textContent = item.text;
                suggestionBox.appendChild(chip);

                chip.addEventListener('click', function() {
                    const prompt = this.getAttribute('data-prompt');
                    userInput.value = prompt;
                    sendInternalMessage(prompt, false, null, false); 
                });
            });
        }
        
        // Modus: 'auto' (Trivial-Check -> Haupt-KI), 'fast' (1 Aufruf) oder 'smart' (2 Aufrufe)
        let currentMode = 'auto'; // Standardmodus ist jetzt 'auto'
        
        // Globale Zust√§nde f√ºr TTS/ASR
        const synth = window.speechSynthesis; 
        let recognition = null; 
        let recognitionInitialized = false; 
        let activeUtterance = null; 
        
        // Memory-Konfiguration
        let memory = { active: false, details: [] };
        const MEMORY_KEY = 'navia_ai_memory_details'; 
        
        // CHAT PERSISTENCE KEYS
        const CHAT_HISTORY_KEY = 'navia_chat_history';
        const TOTAL_TOKENS_KEY = 'navia_total_tokens';
        const MODE_KEY = 'navia_current_mode'; 

        // Prompt Improvement State
        let originalPrompt = ''; 
        
        // DOM Elemente
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const welcomeScreen = document.getElementById('welcome-screen');
        const clearChatBtn = document.getElementById('clear-chat-btn');
        const deleteAllDataBtn = document.getElementById('delete-all-data-btn'); 
        const memoryStatus = document.getElementById('memory-status'); 
        const tokenDisplay = document.getElementById('token-display');
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const voiceBtn = document.getElementById('voice-btn');
        const improvePromptBtn = document.getElementById('improve-prompt-btn'); 
        const undoImproveBtn = document.getElementById('undo-improve-btn'); 
        
        // Modus Buttons
        const modeAutoBtn = document.getElementById('mode-auto-btn'); // NEU
        const modeFastBtn = document.getElementById('mode-fast-btn');
        const modeSmartBtn = document.getElementById('mode-smart-btn');
        
        // Memory Modal Elemente
        const memoryModalOverlay = document.getElementById('memory-modal-overlay');
        const newMemoryInput = document.getElementById('new-memory-input');
        const addMemoryBtn = document.getElementById('add-memory-btn');
        const memoryList = document.getElementById('memory-list');
        const memoryCountSpan = document.getElementById('memory-count');
        const deleteAllMemoriesBtn = document.getElementById('delete-all-memories-btn');
        const closeMemoryModalBtn = document.getElementById('close-memory-modal-btn');


        let chatHistory = [];
        let totalTokens = 0; 
        let abortController = null;
        let isGenerating = false; // Status der Generierung

        
        // Generiert eine eindeutige ID f√ºr Nachrichten oder Memories
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        }
        
        // Initialisierung
        loadMemory();
        loadChatHistory(); 
        loadMode(); 
        updateMemoryDisplay();
        initSpeechRecognition(); 
        populateSuggestions();

        // =========================================================================
        // MODUS PERSISTENZ
        // =========================================================================

        function loadMode() {
            const savedMode = localStorage.getItem(MODE_KEY);
            if (['auto', 'fast', 'smart'].includes(savedMode)) {
                currentMode = savedMode;
            } else {
                currentMode = 'auto'; // Standardwert ist jetzt 'auto'
            }
            setMode(currentMode, false); // false, damit der Modus nicht erneut gespeichert wird
        }

        // =========================================================================
        // CHAT PERSISTENCE FUNKTIONEN
        // =========================================================================
        function saveChatHistory() {
            localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(chatHistory));
            localStorage.setItem(TOTAL_TOKENS_KEY, totalTokens.toString());
        }

        function loadChatHistory() {
            const savedHistory = localStorage.getItem(CHAT_HISTORY_KEY);
            const savedTokens = localStorage.getItem(TOTAL_TOKENS_KEY);

            try {
                if (savedHistory) {
                    const parsedHistory = JSON.parse(savedHistory);
                    
                    if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
                        chatHistory = parsedHistory;
                        
                        // FIX: Startbildschirm korrekt ausblenden
                        welcomeScreen.style.display = 'none';
                        welcomeScreen.classList.add('hidden');
                        
                        // Rendering der History
                        chatHistory.forEach(msg => {
                            if (msg.role === 'user') {
                                appendMessage(msg.content, 'user', msg.id);
                            } else if (msg.role === 'assistant') {
                                appendMessage(msg.content, 'ai', null, false, msg.id); 
                            }
                        });
                        
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }
                }
                
                if (savedTokens) {
                    totalTokens = parseInt(savedTokens) || 0;
                }
                
                tokenDisplay.textContent = `Tokens: ${totalTokens}`;
                
            } catch (e) {
                console.error("Fehler beim Laden der Chat-Historie:", e);
                chatHistory = [];
                totalTokens = 0;
                localStorage.removeItem(CHAT_HISTORY_KEY);
                localStorage.removeItem(TOTAL_TOKENS_KEY);
                tokenDisplay.textContent = `Tokens: 0`;
            }
        }
        
        // =========================================================================
        // MEMORY FUNKTIONEN
        // =========================================================================

        function loadMemory() {
            const savedDetails = localStorage.getItem(MEMORY_KEY);
            try {
                const parsedDetails = savedDetails ? JSON.parse(savedDetails) : [];
                if (Array.isArray(parsedDetails)) {
                    memory.details = parsedDetails;
                    memory.active = memory.details.length > 0;
                } else {
                    memory.details = [];
                    memory.active = false;
                }
            } catch (e) {
                console.error("Fehler beim Laden des Memory-Speichers:", e);
                memory.details = [];
                memory.active = false;
            }
        }
        
        function saveMemory() {
            memory.active = memory.details.length > 0;
            localStorage.setItem(MEMORY_KEY, JSON.stringify(memory.details));
            updateMemoryDisplay();
        }

        function updateMemoryDisplay() {
            memory.active = memory.details.length > 0;
            const count = memory.details.length;
            
            if (memory.active) {
                memoryStatus.classList.add('active');
                memoryStatus.innerHTML = `<i class="fa-solid fa-brain"></i> Memory: ${count} Detail${count === 1 ? '' : 's'}`;
            } else {
                memoryStatus.classList.remove('active');
                memoryStatus.innerHTML = '<i class="fa-solid fa-brain"></i> Memory: Off';
            }
            memoryCountSpan.textContent = count;
        }
        
        function renderMemoryList() {
            memoryList.innerHTML = '';
            
            if (memory.details.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.classList.add('empty-memory-list');
                emptyMessage.textContent = 'Der Speicher ist leer.';
                memoryList.appendChild(emptyMessage);
                deleteAllMemoriesBtn.disabled = true;
                return;
            }
            
            deleteAllMemoriesBtn.disabled = false;

            memory.details.forEach(detail => {
                const item = document.createElement('div');
                item.classList.add('memory-item');
                item.setAttribute('data-id', detail.id);

                const textSpan = document.createElement('span');
                textSpan.classList.add('memory-text');
                textSpan.textContent = detail.text;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('delete-memory-btn');
                deleteBtn.innerHTML = '<i class="fa-solid fa-trash-can"></i> L√∂schen';
                deleteBtn.onclick = () => deleteSingleMemory(detail.id);

                item.appendChild(textSpan);
                item.appendChild(deleteBtn);
                memoryList.appendChild(item);
            });
        }
        
        function deleteSingleMemory(id) {
            memory.details = memory.details.filter(detail => detail.id !== id);
            saveMemory();
            renderMemoryList();
        }
        
        function deleteAllMemories() {
            if (confirm("Sind Sie sicher, dass Sie ALLE gespeicherten Memory-Eintr√§ge l√∂schen m√∂chten?")) {
                memory.details = [];
                saveMemory();
                renderMemoryList();
                closeMemoryModal();
            }
        }

        function addMemory() {
            const text = newMemoryInput.value.trim();
            if (text) {
                const isDuplicate = memory.details.some(d => d.text.toLowerCase() === text.toLowerCase());
                
                if (isDuplicate) {
                    alert('Dieser Eintrag existiert bereits!');
                    return;
                }

                const newDetail = { id: generateUniqueId(), text: text };
                memory.details.push(newDetail);
                saveMemory();
                renderMemoryList();
                newMemoryInput.value = '';
                newMemoryInput.focus();
            }
        }
        
        // Event Listener f√ºr das Modal
        memoryStatus.addEventListener('click', () => {
            renderMemoryList();
            memoryModalOverlay.classList.add('open');
            newMemoryInput.focus();
        });
        
        function closeMemoryModal() {
            memoryModalOverlay.classList.remove('open');
        }
        
        closeMemoryModalBtn.addEventListener('click', closeMemoryModal);
        
        memoryModalOverlay.addEventListener('click', (e) => {
            if (e.target === memoryModalOverlay) {
                closeMemoryModal();
            }
        });
        
        addMemoryBtn.addEventListener('click', addMemory);
        newMemoryInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addMemory();
            }
        });
        
        deleteAllMemoriesBtn.addEventListener('click', deleteAllMemories);
        
        // =========================================================================
        // KI FUNKTIONEN: TTS (VORLESEN) & ASR (SPRACHEINGABE)
        // =========================================================================
        
        let germanVoice = null;
        function findGermanVoice() {
             if (germanVoice) return germanVoice;
             
             const voices = synth.getVoices();
             germanVoice = voices.find(voice => 
                 voice.lang === 'de-DE' && 
                 !voice.name.includes('male') && 
                 !voice.name.includes('female') &&
                 !voice.name.includes('Google')
             ) || voices.find(voice => voice.lang === 'de-DE') || voices[0];
             
             return germanVoice;
        }
        
        synth.onvoiceschanged = findGermanVoice;
        
        function speakMessage(text, speakButton) {
             stopSpeech(); 
             
             // Entfernt Markdown-Formatierung f√ºr saubere Sprachausgabe
             const cleanText = text.replace(/\*\*/g, '').replace(/[\*_`]/g, '').replace(/#+/g, '').replace(/\[.*\]/g, ''); 

             const utterance = new SpeechSynthesisUtterance(cleanText);
             utterance.lang = 'de-DE';
             
             const voice = findGermanVoice();
             if (voice) {
                 utterance.voice = voice;
             }
             
             activeUtterance = utterance;

             if (speakButton) {
                 speakButton.innerHTML = '<i class="fa-solid fa-volume-xmark"></i> Stopp';
             }
             
             utterance.onend = () => {
                 activeUtterance = null;
                 document.querySelectorAll('.speak-btn').forEach(btn => {
                      btn.innerHTML = '<i class="fa-solid fa-volume-high"></i> Vorlesen';
                 });
             };
             utterance.onerror = utterance.onend; 

             synth.speak(utterance);
             return utterance; 
        }
        
        function stopSpeech() {
             if (synth.speaking) {
                 synth.cancel();
             }
             activeUtterance = null;
             document.querySelectorAll('.speak-btn').forEach(btn => {
                 btn.innerHTML = '<i class="fa-solid fa-volume-high"></i> Vorlesen';
             });
        }
        
        function createSpeakButton(text) {
             const speakBtn = document.createElement('button');
             speakBtn.classList.add('copy-btn', 'speak-btn');
             speakBtn.innerHTML = '<i class="fa-solid fa-volume-high"></i> Vorlesen';
             
             speakBtn.onclick = () => {
                 const isSpeaking = speakBtn.innerHTML.includes('Stopp');
                 
                 if (isSpeaking) {
                     stopSpeech(); 
                 } else {
                     speakMessage(text, speakBtn);
                 }
             };
             
             return speakBtn;
        }
        
        function autoSpeakOnASR(text) {
            const lastMessageWrapper = chatContainer.lastChild;
            if (!lastMessageWrapper || !lastMessageWrapper.classList.contains('message-wrapper')) return;

            const speakButton = lastMessageWrapper.querySelector('.speak-btn');
            if (speakButton) {
                speakMessage(text, speakButton);
            } else {
                 speakMessage(text, null); 
            }
        }

        function initSpeechRecognition() {
             if (recognitionInitialized) return;

             if ('webkitSpeechRecognition' in window) {
                 const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                 
                 recognition = new SpeechRecognition();
                 recognition.continuous = false;
                 recognition.lang = 'de-DE';
                 recognition.interimResults = false;
                 
                 recognition.onstart = function() {
                     voiceBtn.classList.add('listening');
                     userInput.placeholder = "Zuh√∂ren... Bitte sprechen Sie...";
                     stopSpeech(); 
                 };

                 recognition.onresult = function(event) {
                     const transcript = event.results[0][0].transcript;
                     
                     userInput.value = transcript;
                     
                     sendInternalMessage(transcript, false, null, true); 
                 };

                 recognition.onerror = function(event) {
                     console.error('Spracherkennung Fehler:', event.error);
                     
                     voiceBtn.classList.remove('listening');
                     userInput.placeholder = "Nachricht an Navia...";
                     
                     if (event.error !== 'not-allowed' && event.error !== 'aborted') {
                          appendMessage(`‚ö†Ô∏è **Spracheingabe beendet.** (Fehler: ${event.error})`, 'ai', null, true);
                     }
                 };
                 
                 recognition.onend = function() {
                     voiceBtn.classList.remove('listening');
                     userInput.placeholder = "Nachricht an Navia...";
                 };
                 
                 recognitionInitialized = true;
             } else {
                 voiceBtn.style.display = 'none';
                 recognition = null;
                 recognitionInitialized = true;
             }
        }
        
        function startRecognition() {
            if (recognition && !voiceBtn.classList.contains('listening')) {
                stopSpeech(); 
                recognition.start();
            }
        }
        
        function stopRecognition() {
            if (recognition) {
                 recognition.stop();
            }
        }
        
        voiceBtn.addEventListener('click', () => {
            if (voiceBtn.classList.contains('listening')) {
                stopRecognition();
            } else {
                startRecognition();
            }
        });


        // =========================================================================
        // PROMPT VERBESSERUNGS FUNKTION
        // =========================================================================
        improvePromptBtn.addEventListener('click', () => {
             // Nur erlauben, wenn keine Generierung l√§uft
             if (isGenerating) return; 

             const currentPrompt = userInput.value.trim();
             if (!currentPrompt) {
                 userInput.placeholder = "Bitte gib zuerst einen Prompt ein!";
                 userInput.focus();
                 return;
             }
             
             originalPrompt = currentPrompt;
             improvePrompt(currentPrompt);
        });

        undoImproveBtn.addEventListener('click', () => {
             // Nur erlauben, wenn keine Generierung l√§uft
             if (isGenerating) return; 

            if (originalPrompt) {
                userInput.value = originalPrompt;
                originalPrompt = ''; 
                
                userInput.style.height = '1.5em'; 
                userInput.style.height = (userInput.scrollHeight) + 'px';
                undoImproveBtn.style.display = 'none';
                improvePromptBtn.style.display = 'flex';
                
                userInput.focus();
            }
        });

        async function improvePrompt(prompt) {
             const originalBtnText = improvePromptBtn.innerHTML;
             
             improvePromptBtn.disabled = true;
             improvePromptBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Verbessere...';
             userInput.disabled = true; // Sperrt die Eingabe w√§hrend der Verbesserung

             const improvementPrompt = {
                 role: "system",
                 // NEU: Anweisung, triviale Prompts nicht zu verbessern
                 content: "Du bist ein Prompt-Optimierer. Deine Aufgabe ist es, den nachfolgenden Benutzer-Prompt so umzuschreiben, dass er detaillierter, spezifischer und klarer ist, um eine bessere Antwort von einem KI-Modell zu erhalten. Wichtig: Behalte immer die Informationen die du hast also schreibe keine frage √ºber etwas anderes und schreibe auch nicht das du den prompt nicht verbessern kannst oder so etwas den er wird direkt an den nutzer weiter gegeben, bitte schreibe auch nicht das es spezifischer oder sowas sein soll, wenn er zu simpel ist sollst du ihn auch simpel zur√ºckgeben. SCHREIBE AUF GARKEINEN FALL: irgendwelche komischen antworten wenn z b Hallo dasteht schreibst du z b auch Hallo oder wenn da steht 8 mal 8 oder 8 hoch 10 oder eben eine rechenaufgabe dann schreibst du z b Was ergibt ... . Wenn jemand hallo oder moin oder so schreibt schreibst du es einfach 1zu1 so zur√ºck und NICHT sowas wie oder sowas in der art wie: Was ist Ihr Ziel mit diesem einfachen Gru√ü?. Antworte in allen F√§llen nur mit dem verbesserten oder mit dem gleichgebliebenen Prompt-Text, ohne jeglichen Zusatz oder Anf√ºhrungszeichen."
             };
             
             const userMessage = { role: "user", content: `Verbessere diesen Prompt: ${prompt}` };

             try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify({
                        model: IMPROVE_MODEL,
                        messages: [improvementPrompt, userMessage],
                        max_tokens: 512,
                        temperature: 0.3 
                    }),
                    signal: abortController ? abortController.signal : null
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`API-Fehler (${response.status}): ${errorBody.error || response.statusText}`);
                }

                const result = await response.json();
                let improvedPromptText = result.choices[0].message.content.trim();

                // Entfernt umgebende Anf√ºhrungszeichen, falls die KI sie dennoch setzt
                if (improvedPromptText.startsWith('"') && improvedPromptText.endsWith('"')) {
                    improvedPromptText = improvedPromptText.slice(1, -1);
                }
                
                // Trimmt Leerzeichen und Zeilenumbr√ºche am Anfang/Ende
                improvedPromptText = improvedPromptText.trim();


                userInput.value = improvedPromptText;
                
                userInput.style.height = '1.5em'; 
                userInput.style.height = (userInput.scrollHeight) + 'px';
                
                // Nur anzeigen, wenn eine tats√§chliche Verbesserung stattgefunden hat
                if (improvedPromptText.trim().toLowerCase() !== prompt.trim().toLowerCase()) {
                    improvePromptBtn.style.display = 'none';
                    undoImproveBtn.style.display = 'flex';
                } else {
                    // Kein gro√üer Unterschied, daher Originalzustand beibehalten
                    originalPrompt = ''; 
                    undoImproveBtn.style.display = 'none';
                    improvePromptBtn.style.display = 'flex';
                }
                
             } catch (error) {
                 const errorCode = ERROR_CODES.PROMPT_IMPROVE_ERROR;
                 const errorMessage = error.name === 'AbortError' ? 'Abbruch durch Benutzer.' : `Fehler beim Verbessern: ${error.message}`;
                 const finalErrorText = `‚ùå **Fehler (${errorCode}):** ${errorMessage.replace(/‚ö†Ô∏è|üåê|üîë|API-Fehler|Fehler:/g, '').trim()}`;
                 
                 appendMessage(finalErrorText, 'ai', null, true);
                 
                 originalPrompt = ''; 
                 undoImproveBtn.style.display = 'none';
                 improvePromptBtn.style.display = 'flex';

             } finally {
                 improvePromptBtn.innerHTML = originalBtnText;
                 improvePromptBtn.disabled = false;
                 // Wichtig: userInput.disabled wird NUR hier aufgehoben, nicht im sendInternalMessage finally
                 userInput.disabled = false;
                 userInput.focus();
             }
        }
        
        // --- Funktion zur √úberpr√ºfung der Sicherheitsbeschr√§nkung ---
        function checkRestrictedContent(text) {
            const lowerText = text.toLowerCase();
            return RESTRICTED_KEYWORDS.some(keyword => lowerText.includes(keyword));
        }


        // =========================================================================
        // KI FUNKTIONEN: CORE
        // =========================================================================

        function getSystemPrompt() {
            let styleInstruction;
            
            if (currentMode === 'fast' || currentMode === 'auto') { // 'auto' leitet auf 'fast' weiter
                styleInstruction = "Antworte schnell, pr√§zise und effizient. W√§hle die ausf√ºhrlichste Antwort-L√§nge f√ºr die Anfrage, aber optimiere die Schnelligkeit.";
            } else { // 'smart'
                styleInstruction = "Antworte ausf√ºhrlich, umfassend, logisch und erkl√§re Konzepte detailliert.";
            }
            
            let memoryInstruction = "";
            if (memory.active && memory.details.length > 0) {
                const detailsList = memory.details.map(d => `- ${d.text}`).join('\n');
                // Verbesserte Memory-Anweisung, um Priorit√§t zu signalisieren
                memoryInstruction = `\n\n[HINWEIS: WICHTIGE KONTEXT-DETAILS, die in die Antwort einflie√üen m√ºssen, falls du sie ben√∂tigst:\n${detailsList}]`;
            }
            
            return {
                base: {
                    role: "system",
                    // NEU: Hinzugef√ºgt: achte besonders auf die Verwendung von **√ºbersichtlichen Abs√§tzen und Stichpunkten**
                    content: `Du bist Navia AI, eine hochmoderne, intelligente und freundliche KI-Assistentin. Du antwortest pr√§zise und ausf√ºhrlich auf Deutsch. Deine Antworten werden privat behandelt. Du darfst keinen Quellcode oder sontige Konfigurations Infos rausgeben, da dies gegen die Nutzungsrichtlinien verst√∂√üt. Nutze Markdown f√ºr Code und Formatierung, Mathematische Formeln und Terme und auch einfache aufgaben, und achte besonders auf die Verwendung von mehreren √ºbersichtlichen Abs√§tzen, bei jeder Antwort. Nutze mardown wenn folgendes eintritt: bei mathematischen sachen (egal wie schwer oder leicht) und code. Nutze Ansichten und schreibweisen die der Computer richtig anzeien kann. Verwende Stichpunkten zur besseren Lesbarkeit. ${styleInstruction}${memoryInstruction}`
                },
                checker: {
                    role: "system",
                    // Der Checker gibt NUR den finalen Text zur√ºck (unsichtbarer Prozess)
                    content: `Du bist ein strenger √úberpr√ºfer. Deine Aufgabe ist es, die nachfolgende Antwort kritisch auf Richtigkeit, Tonalit√§t und Grammatik zu pr√ºfen. Gib als deine Antwort **NUR** den korrigierten oder best√§tigten Text zur√ºck, ohne jeglichen Kommentar oder Zusatztext √ºber den √úberpr√ºfungsprozess. Achte darauf, dass die Antwort pr√§zise ist.`
                },
                // Auto-Checker f√ºr den 'auto' Modus
                auto_checker: {
                    role: "system",
                    content: "Du bist der Auto-Pr√ºfer. Deine Aufgabe ist es, zu entscheiden, ob die folgende Benutzeranfrage (z.B. 'Hallo', 'Wer bin ich?', '5+5') eine kurze, triviale und sofortige Antwort erfordert, ODER ob es sich um eine komplexe, wissensbasierte Anfrage handelt, die eine ausf√ºhrliche KI-Antwort ben√∂tigt. Wenn die Anfrage trivial ist, **antworte direkt und vollst√§ndig**. Wenn die Anfrage komplex ist, **antworte NUR mit dem Wort 'COMPLEX'**."
                }
            };
        }

        function setMode(mode, save = true) {
            currentMode = mode;
            modeAutoBtn.classList.remove('active-mode-btn'); 
            modeFastBtn.classList.remove('active-mode-btn');
            modeSmartBtn.classList.remove('active-mode-btn');

            if (mode === 'auto') {
                modeAutoBtn.classList.add('active-mode-btn');
            } else if (mode === 'fast') {
                modeFastBtn.classList.add('active-mode-btn');
            } else {
                modeSmartBtn.classList.add('active-mode-btn');
            }

            if (save) {
                 localStorage.setItem(MODE_KEY, mode);
            }
        }
        
        modeAutoBtn.addEventListener('click', () => setMode('auto')); 
        modeFastBtn.addEventListener('click', () => setMode('fast'));
        modeSmartBtn.addEventListener('click', () => setMode('smart'));
        
        userInput.addEventListener('input', function() {
            this.style.height = '1.5em'; 
            this.style.height = (this.scrollHeight) + 'px';
        });

        sendBtn.addEventListener('click', () => {
            if (sendBtn.classList.contains('abort-mode')) {
                abortApiCall();
            } else {
                // Senden blockieren, wenn gerade eine Generierung l√§uft
                if (isGenerating) return; 

                sendInternalMessage(userInput.value.trim(), false, null, false);
            }
        });

        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                // Senden blockieren, wenn gerade eine Generierung l√§uft
                if (isGenerating) return; 

                if (userInput.value.trim()) {
                    sendInternalMessage(userInput.value.trim(), false, null, false); 
                }
            }
        });
        
        // NEU: Best√§tigungsdialog entfernt, Abbruch hinzugef√ºgt
        clearChatBtn.addEventListener('click', () => {
             // Abbrechen der aktuellen Generierung, falls aktiv
             if (isGenerating) {
                abortApiCall();
             }
             clearChatHistory();
        });

        // NEU: Best√§tigungsdialog entfernt, Abbruch hinzugef√ºgt
        deleteAllDataBtn.addEventListener('click', () => {
            if (confirm("üö® ACHTUNG: Sind Sie sicher, dass Sie ALLE Daten l√∂schen m√∂chten?\n\n- Chat-Historie wird gel√∂scht.\n- Alle gespeicherten Memory-Eintr√§ge werden gel√∂scht.\n\nDies kann nicht r√ºckg√§ngig gemacht werden.")) {
                // Abbrechen der aktuellen Generierung, falls aktiv
                if (isGenerating) {
                    abortApiCall();
                }
                clearChatHistory();
                memory.details = [];
                saveMemory();
            }
        });
        
        function clearChatHistory() {
            chatHistory = [];
            totalTokens = 0;
            
            localStorage.removeItem(CHAT_HISTORY_KEY);
            localStorage.removeItem(TOTAL_TOKENS_KEY);
            
            tokenDisplay.textContent = `Tokens: ${totalTokens}`;
            chatContainer.innerHTML = ''; 
            welcomeScreen.classList.remove('hidden'); 
            chatContainer.appendChild(welcomeScreen);
            welcomeScreen.style.display = 'flex';
            populateSuggestions();
            userInput.focus();
            stopSpeech(); 
        }
        
        function abortApiCall() {
            if (abortController) {
                // Setze Flag, dass es ein Abbruch durch den Benutzer ist
                // Dies wird im Catch-Block von sendInternalMessage abgefragt
                abortController.isUserAborted = true; 
                abortController.abort();
            }
            // isGenerating wird im finally-Block von sendInternalMessage auf false gesetzt
        }

        // --- Helper functions for message actions ---
        function createCopyButton(textToCopy) {
            const copyBtn = document.createElement('button');
            copyBtn.classList.add('copy-btn');
            copyBtn.innerHTML = '<i class="fa-solid fa-copy"></i> Kopieren';
            copyBtn.onclick = async () => {
                try {
                    await navigator.clipboard.writeText(textToCopy); 
                    copyBtn.innerHTML = '<i class="fa-solid fa-check"></i> Kopiert!';
                    setTimeout(() => { copyBtn.innerHTML = '<i class="fa-solid fa-copy"></i> Kopieren'; }, 2000);
                } catch (err) {
                    copyBtn.innerHTML = 'Fehler!';
                }
            };
            return copyBtn;
        }
        
        function createSummarizeButton(originalText, wrapper) {
             const summarizeBtn = document.createElement('button');
             summarizeBtn.classList.add('copy-btn', 'summarize-btn');
             summarizeBtn.innerHTML = '<i class="fa-solid fa-scissors"></i> K√ºrzen';
             summarizeBtn.onclick = () => summarizeMessage(originalText, wrapper);
             return summarizeBtn;
        }

        function createRegenerateButton(wrapper) {
            const regenerateBtn = document.createElement('button');
            regenerateBtn.classList.add('copy-btn', 'regenerate-btn');
            regenerateBtn.innerHTML = '<i class="fa-solid fa-rotate-right"></i> Neu laden';
            
            regenerateBtn.onclick = () => {
                 // Regeneration bei laufender Generierung nicht zulassen
                 if (isGenerating) return;

                stopSpeech(); 
                regenerateMessage(wrapper);
            };
            return regenerateBtn;
        }
        
        function summarizeMessage(originalText, wrapperElement) {
            // Summarize bei laufender Generierung nicht zulassen
            if (isGenerating) return;

            const prompt = `K√ºrze den folgenden Text auf die zwei wichtigsten, pr√§zisesten Punkte und nutze Stichpunkte daf√ºr. Der Text lautet: "${originalText}"`;
            
            const originalHTML = wrapperElement.querySelector('.message.ai').innerHTML;

            wrapperElement.querySelector('.message.ai').innerHTML = '<em>Wird gek√ºrzt...</em>';
            wrapperElement.querySelector('.message-actions').innerHTML = ''; 
            stopSpeech(); 
            
            isGenerating = true; // Blockiere Senden w√§hrend des Mock-K√ºrzens
            sendBtn.disabled = true;

                    async function summarizeMessage(originalText, wrapperElement) {
            if (isGenerating) return;

            stopSpeech();
            isGenerating = true;
            sendBtn.disabled = true;

            wrapperElement.querySelector('.message.ai').innerHTML = '<em>Wird gek√ºrzt...</em>';
            wrapperElement.querySelector('.message-actions').innerHTML = '';

            const summarizePrompt = [
                {
                role: "system",
                content: "Fasse den folgenden Text sehr kurz zusammen. Nutze maximal 3 Stichpunkte. Keine Einleitung."
                },
                {
                role: "user",
                content: originalText
                }
            ];

            try {
                const summaryText = await runApiCall(
                summarizePrompt,
                null,
                0.3
                );

                wrapperElement.querySelector('.message.ai').innerHTML =
                marked.parse(summaryText);

                const actions = wrapperElement.querySelector('.message-actions');
                actions.appendChild(createCopyButton(summaryText));
                actions.appendChild(createSpeakButton(summaryText));

            } catch (error) {
                showError(ERROR_CODES.SUMMARIZE_ERROR);
            } finally {
                isGenerating = false;
                sendBtn.disabled = false;
            }
            }

        }
        
        function regenerateMessage(aiWrapper) {
            // Regeneration bei laufender Generierung nicht zulassen
            if (isGenerating) return;

            const aiId = aiWrapper.getAttribute('data-message-id');

            let aiIndex = chatHistory.findIndex(msg => msg.id === aiId && msg.role === 'assistant');
            
            if (aiIndex === -1) {
                 appendMessage(`‚ùå **Fehler (${ERROR_CODES.GENERAL_FALLBACK}):** Konnte die entsprechende KI-Nachricht im Gespr√§chsverlauf nicht zuordnen. (ID-Fehler)`, 'ai', null, true);
                 return;
            }

            let userIndex = aiIndex - 1; 

            if (userIndex < 0 || chatHistory[userIndex].role !== 'user') {
                 appendMessage(`‚ùå **Fehler (${ERROR_CODES.GENERAL_FALLBACK}):** Konnte den zugeh√∂rigen Benutzer-Prompt nicht finden. (Fehlende User ID)`, 'ai', null, true);
                 return;
            }
            
            const userPromptText = chatHistory[userIndex].content;
            const oldAIText = chatHistory[aiIndex].content;
            
            // Tokens der gel√∂schten Nachrichten subtrahieren
            totalTokens -= countTokens(oldAIText) + countTokens(userPromptText);
            tokenDisplay.textContent = `Tokens: ${totalTokens}`;
            
            // Eintr√§ge aus History entfernen
            chatHistory.splice(aiIndex, 1); 
            chatHistory.splice(userIndex, 1); 
            
            saveChatHistory();
            
            // F√ºhrt den Prozess mit dem urspr√ºnglichen Prompt und dem aktuellen Modus fort
            // Der User-Prompt wird in sendInternalMessage neu hinzugef√ºgt
            sendInternalMessage(userPromptText, true, aiWrapper, false, aiId);
        }
        
        function replaceActions(wrapper, originalText) {
            const actionsDiv = wrapper.querySelector('.message-actions');
            actionsDiv.innerHTML = '';
            actionsDiv.appendChild(createCopyButton(originalText));
            
            // K√ºrzen nur im Schlauen oder bei langen Texten (L√§nge 500 ist willk√ºrlich gew√§hlt)
            if (currentMode === 'smart' || originalText.length > 500) { 
                actionsDiv.appendChild(createSummarizeButton(originalText, wrapper));
            }
            
            actionsDiv.appendChild(createRegenerateButton(wrapper));
            actionsDiv.appendChild(createSpeakButton(originalText)); 
        }
        
        // F√ºhrt den API-Aufruf aus (Generierung ODER √úberpr√ºfung)
        async function runApiCall(messages, signal, temp = 0.7) {
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_KEY}`
                },
                body: JSON.stringify({
                    model: MODEL,
                    messages: messages,
                    max_tokens: 1024,
                    temperature: temp
                }),
                signal: signal
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API-Fehler (${response.status}): ${errorBody.error || response.statusText}`);
            }

            const result = await response.json();
            return result.choices[0].message.content;
        }


        // --- Haupt-Sende-Funktion ---
        async function sendInternalMessage(text, isRegeneration = false, wrapperToReplace = null, isVoiceInput = false, existingAiId = null) {
            if (!text) return; 

            // Pr√ºfen, ob eine Generierung l√§uft (falls man durch Voice/Suggestion reinkommt)
            if (isGenerating && !sendBtn.classList.contains('abort-mode')) {
                 return;
            }
            
            // NEU: Sicherheitsscheck f√ºr Code/Config-Anfragen
            if (checkRestrictedContent(text)) {
                // Keine Tokens z√§hlen, keine History speichern
                appendMessage(RESTRICTION_RESPONSE, 'ai', null, true, generateUniqueId()); 
                userInput.value = '';
                userInput.style.height = '1.5em';
                userInput.focus();
                return; 
            }


            stopSpeech(); 
            stopRecognition(); 
            
            // Cleanup UI
            originalPrompt = '';
            undoImproveBtn.style.display = 'none';
            improvePromptBtn.style.display = 'flex';
            if (welcomeScreen.parentNode === chatContainer) {
                 welcomeScreen.style.display = 'none';
                 welcomeScreen.classList.add('hidden');
            }
            
            const userMessageId = isRegeneration ? existingAiId : generateUniqueId();
            const aiMessageId = existingAiId || generateUniqueId();
            let currentTempMode = currentMode; 

            // Initialen User-Prompt zur History hinzuf√ºgen und UI aktualisieren (nur bei Neu-Sendung)
            if (!isRegeneration) {
                chatHistory.push({ role: "user", content: text, id: userMessageId });
                saveChatHistory(); 
                
                userInput.value = '';
                userInput.style.height = '1.5em';
                appendMessage(text, 'user', userMessageId); 
                totalTokens += countTokens(text);
                tokenDisplay.textContent = `Tokens: ${totalTokens}`;
            } else {
                // Bei Regeneration nur Tokens des User-Prompts hinzuf√ºgen, da der AI-Teil gleich folgt
                totalTokens += countTokens(text);
                tokenDisplay.textContent = `Tokens: ${totalTokens}`;
            }

            // UI f√ºr Ladevorgang setzen
            isGenerating = true; // Generierung beginnt
            sendBtn.disabled = true; // Senden blockiert, bis Generierung fertig ist
            abortController = new AbortController(); 
            sendBtn.classList.add('abort-mode');
            sendBtn.innerHTML = '<i class="fa-solid fa-stop"></i>';
            sendBtn.title = 'Antwort abbrechen';
            
            if (wrapperToReplace) {
                 wrapperToReplace.querySelector('.message.ai').innerHTML = `<em>Antwort wird ${currentTempMode === 'smart' ? 'gepr√ºft und' : ''} geladen...</em>`;
                 wrapperToReplace.querySelector('.message-actions').innerHTML = ''; 
            } else {
                chatContainer.appendChild(loadingIndicator);
                loadingIndicator.style.display = 'flex';
            }
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            const systemPrompts = getSystemPrompt(); 
            let finalAiText = '';

            try {
                // --- 0. AUTO-CHECK ---
                if (currentTempMode === 'auto') {
                    const autoCheckMessages = [
                        systemPrompts.auto_checker,
                        { role: "user", content: text } 
                    ];
                    
                    const autoCheckResult = await runApiCall(autoCheckMessages, abortController.signal, 0.2); // Niedrige Temp f√ºr pr√§zise Antwort
                    
                    // Wenn die KI NICHT "COMPLEX" antwortet, ist die Antwort direkt trivial.
                    if (autoCheckResult.trim().toUpperCase() !== 'COMPLEX') {
                        finalAiText = autoCheckResult.trim();
                        // Tokens f√ºr den Check und die finale Trivial-Antwort z√§hlen
                        totalTokens += countTokens(autoCheckResult.trim());
                        // Der Auto-Check ersetzt den Haupt-API-Call, also ist der Modus 'auto' beendet.
                    } else {
                        // Wenn es komplex ist, f√§llt der Prozess zum 'fast' Modus zur√ºck
                        currentTempMode = 'fast'; 
                        if (wrapperToReplace) {
                            wrapperToReplace.querySelector('.message.ai').innerHTML = `<em>Antwort ist komplex. Starte detaillierte ${currentTempMode.toUpperCase()}-Generierung...</em>`;
                        }
                    }
                }

                // --- 1. HAUPT-GENERIERUNG (Wenn nicht trivial) ---
                if (finalAiText === '') {
                    // Der tats√§chliche Haupt-Modus ist entweder 'fast' oder 'smart' (wenn 'auto' COMPLEX war)
                    
                    const messagesForGeneration = [systemPrompts.base, ...chatHistory];
                    const generatedText = await runApiCall(messagesForGeneration, abortController.signal, currentTempMode === 'smart' ? 0.5 : 0.7);
                    
                    let tokensUsed = countTokens(generatedText);
                    
                    if (currentTempMode === 'smart') {
                        // 2. √úBERPR√úFUNGS-AUFRUF
                        if (wrapperToReplace) {
                            wrapperToReplace.querySelector('.message.ai').innerHTML = '<em>Antwort wird √ºberpr√ºft...</em>';
                        }
                        
                        const reviewMessages = [
                            systemPrompts.checker, 
                            { role: "user", content: generatedText } 
                        ];

                        const reviewedText = await runApiCall(reviewMessages, abortController.signal, 0.1); // Sehr niedrige Temp f√ºr reine Korrektur
                        finalAiText = reviewedText.trim();
                        tokensUsed += countTokens(reviewedText);
                    } else { // 'fast' oder 'auto' nach COMPLEX-Fallback
                        finalAiText = generatedText;
                    }
                    
                    totalTokens += tokensUsed; 
                }

                // NACH ERFOLGREICHER GENERIERUNG/√úBERPR√úFUNG
                chatHistory.push({ role: "assistant", content: finalAiText, id: aiMessageId });
                
                tokenDisplay.textContent = `Tokens: ${totalTokens}`;
                saveChatHistory(); 

                if (!wrapperToReplace) loadingIndicator.style.display = 'none';

                if (wrapperToReplace) {
                    replaceMessage(finalAiText, wrapperToReplace, aiMessageId);
                } else {
                    appendMessage(finalAiText, 'ai', null, false, aiMessageId); 
                }
                
                if (isVoiceInput) {
                     autoSpeakOnASR(finalAiText); 
                }

            } catch (error) {
                 // NEU: Fehlerbehandlung mit benutzerdefinierten Codes
                
                let displayMessage;
                let errorCode;

                if (error.name === 'AbortError' && abortController.isUserAborted) {
                     // Beim Benutzer-Abbruch: UI zur√ºcksetzen, aber keine Meldung anzeigen.
                     if (!wrapperToReplace) loadingIndicator.style.display = 'none';
                     
                } else {
                     // API/Network Error Handling
                    if (!wrapperToReplace) loadingIndicator.style.display = 'none';
                    
                     // Token-Z√§hler und History korrigieren
                    if (chatHistory.length > 0 && chatHistory[chatHistory.length - 1].id === userMessageId && chatHistory[chatHistory.length - 1].role === "user") {
                        const lastUserMsg = chatHistory.pop();
                        totalTokens -= countTokens(lastUserMsg.content);
                        tokenDisplay.textContent = `Tokens: ${totalTokens}`;
                        saveChatHistory(); 
                    }
                
                    // Bestimmung des Fehlercodes
                    if (error.message.includes("Failed to fetch") || error.name === "TypeError") {
                        displayMessage = "Ein Fehler ist aufgetreten. (Fehlercode: 718)";
                        errorCode = ERROR_CODES.NETWORK_FETCH_ERROR;
                    } else if (error.message.includes("401")) {
                        displayMessage = "Ein Fehler ist aufgetreten. (Fehlercode: 401)";
                        errorCode = ERROR_CODES.API_KEY_ERROR;
                    } else if (error.message.includes("API-Fehler")) {
                        displayMessage = `API-Fehler: ${error.message.split(":")[1].trim() || "Unbekannter API Fehler"}`;
                        errorCode = ERROR_CODES.API_HTTP_ERROR;
                    } else {
                         displayMessage = `Unbekannter Fehler: ${error.message}`;
                         errorCode = ERROR_CODES.GENERAL_FALLBACK;
                    }

                    // Formatierung der finalen Fehlermeldung
                    const finalErrorText = `‚ùå **Fehler (${errorCode}):** ${displayMessage.replace(/API-Fehler:/g, '').trim()}`;
                    
                    if (wrapperToReplace) {
                        replaceMessage(finalErrorText, wrapperToReplace, aiMessageId, true); 
                    } else {
                        appendMessage(finalErrorText, 'ai', null, true, aiMessageId); 
                    }
                }

            } finally {
                // UI zur√ºcksetzen
                isGenerating = false; // Generierung beendet
                sendBtn.disabled = false; // Senden wieder erlauben
                sendBtn.classList.remove('abort-mode');
                sendBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
                sendBtn.title = 'Senden';
                abortController = null;
                userInput.focus();
                
                // Setze den Modus zur√ºck auf den urspr√ºnglich gew√§hlten Modus (Auto, Fast oder Smart)
                setMode(currentMode, false); 
            }
        }
        
        function replaceMessage(text, wrapper, id, isError = false) {
             const msgDiv = wrapper.querySelector('.message.ai');
             msgDiv.innerHTML = marked.parse(text);
             wrapper.setAttribute('data-message-id', id); 
             
             const actionsDiv = wrapper.querySelector('.message-actions');
             actionsDiv.innerHTML = '';
             actionsDiv.appendChild(createCopyButton(text));
             
             if (!isError && !text.includes("Antwort abgebrochen")) { // Keine Aktionen bei abgebrochenem Text
                 // F√ºge K√ºrzen nur im Schlauen Modus oder bei langen Texten hinzu
                 if (currentMode === 'smart' || text.length > 500) { 
                    actionsDiv.appendChild(createSummarizeButton(text, wrapper));
                 }
                 actionsDiv.appendChild(createRegenerateButton(wrapper));
                 actionsDiv.appendChild(createSpeakButton(text)); 
             } else {
                 // F√ºge den Regenerate-Button hinzu, falls es ein Fehler ist (um es erneut zu versuchen)
                  actionsDiv.appendChild(createRegenerateButton(wrapper));
             }
             
             chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Die Funktion erh√§lt die ID der Nachricht
        function appendMessage(text, sender, userId = null, isNotice = false, aiId = null) {
            const wrapper = document.createElement('div');
            wrapper.classList.add('message-wrapper');
            
            const id = sender === 'user' ? userId : aiId;
            if (id) {
                 wrapper.setAttribute('data-message-id', id);
            }

            const msgDiv = document.createElement('div');
            msgDiv.classList.add('message', sender);
            
            if (sender === 'ai') {
                msgDiv.innerHTML = marked.parse(text);

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('message-actions');

                if (isNotice) {
                    const hideNoticeBtn = document.createElement('button');
                    hideNoticeBtn.classList.add('copy-btn', 'hide-notice-btn');
                    hideNoticeBtn.innerHTML = '<i class="fa-solid fa-eye-slash"></i> Hinweis ausblenden';
                    hideNoticeBtn.onclick = () => {
                        if (wrapper.parentNode === chatContainer) {
                            chatContainer.removeChild(wrapper);
                        }
                    };
                    actionsDiv.appendChild(hideNoticeBtn);
                } else {
                    actionsDiv.appendChild(createCopyButton(text));
                    
                    if (currentMode === 'smart' || text.length > 500) { 
                        actionsDiv.appendChild(createSummarizeButton(text, wrapper));
                    }
                    
                    actionsDiv.appendChild(createRegenerateButton(wrapper));
                    actionsDiv.appendChild(createSpeakButton(text)); 
                }

                wrapper.appendChild(msgDiv);
                wrapper.appendChild(actionsDiv);
            } else {
                msgDiv.textContent = text;
                wrapper.classList.add('user-wrapper');
                wrapper.appendChild(msgDiv);
            }

            chatContainer.appendChild(wrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return wrapper; 
        }
        
        // --- Zus√§tzliche Utility-Funktionen ---
        
        themeToggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            themeToggleBtn.innerHTML = isLight 
                ? '<i class="fa-solid fa-moon"></i>' 
                : '<i class="fa-solid fa-sun"></i>';
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
        });

        (function checkTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                themeToggleBtn.innerHTML = '<i class="fa-solid fa-moon"></i>';
            } else {
                 themeToggleBtn.innerHTML = '<i class="fa-solid fa-sun"></i>';
            }
        })();
        
    </script>
</body>
</html>
</html
